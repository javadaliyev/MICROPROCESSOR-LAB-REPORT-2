#define F_CPU 16000000UL // 16 MHz clock
#include <avr/io.h>               
#include <util/delay.h>           

#define SLAVE_ADDR 0x10 // Slave address
#define BUTTON_B   PD2  // Button pin
#define LED_B      PD3  // LED pin

void TWI_SlaveInit(uint8_t address)
{
    PRR &= ~(1 << PRTWI);  // Enable TWI
    TWAR = (address << 1);  // Set slave address
    TWCR = (1 << TWEA) | (1 << TWEN); // Enable TWI and ACK
}

void io_init(void)
{
    DDRD &= ~(1 << BUTTON_B); // Set BUTTON_B as input
    PORTD |= (1 << BUTTON_B); // Enable pull-up on BUTTON_B
    DDRD |= (1 << LED_B); // Set LED_B as output
}

int main(void)
{
    io_init(); // Initialize pins
    PORTC |= (1 << PC4) | (1 << PC5); // Enable pull-ups on SDA/SCL
    TWI_SlaveInit(SLAVE_ADDR);  // Initialize TWI in slave mode

    uint8_t received = 0;  // Last byte received
    uint8_t button_b_state = 0; // Current button state
    static uint8_t led_b_state = 0; // LED_B state
    static uint8_t prev_button_b_state = 0; // Previous button state
    uint8_t toggle_event_b = 0; // Button press event flag

    while (1)
    {
        while (!(TWCR & (1 << TWINT))); // Wait for TWI event

        uint8_t status = TWSR & 0xF8; // Get status code

        // Master to slave write (SLA+W)
        if (status == 0x60 || status == 0x68) // Own address + write
        {
            TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // Clear flag, ACK next byte
        }
        // Data received from master
        else if (status == 0x80) // Data byte received, ACK returned
        {
            received = TWDR; // Read received data
            if (received == 0x01) // If toggle command received
            {
                led_b_state ^= 1; // Toggle LED state
                if (led_b_state)
                    PORTD |= (1 << LED_B); // Turn LED_B on
                else
                    PORTD &= ~(1 << LED_B); // Turn LED_B off
            }
            TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // Ready for next byte
        }
        // Master from slave read (SLA+R)
        else if (status == 0xA8 || status == 0xB0) // Master read request
        {
            button_b_state = !(PIND & (1 << BUTTON_B)); // Read button state
            toggle_event_b = 0; // Default: no press event
            if (button_b_state == 1 && prev_button_b_state == 0) // Rising edge
            {
                toggle_event_b = 1; // Set toggle event flag
            }
            prev_button_b_state = button_b_state; // Store current button state

            TWDR = toggle_event_b ? 0x01 : 0x00;  // Send button state to master
            TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // Start transmission
        }
        // Master done reading
        else if (status == 0xC0 || status == 0xC8) // Read complete
        {
            TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // Idle state
        }
        else
        {
            TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // Default: recovery state
        }
    }
}
