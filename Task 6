#include <avr/io.h>       
#include <avr/interrupt.h> 
#include <util/delay.h>    

volatile uint8_t digit = 0; // Current digit 0â€“9
volatile uint8_t paused = 0; // Pause state

// 7-segment patterns
const uint8_t patterns[10] = {
  0b00111111, // 0
  0b00000110, // 1
  0b01011011, // 2
  0b01001111, // 3
  0b01100110, // 4
  0b01101101, // 5
  0b01111101, // 6
  0b00000111, // 7
  0b01111111, // 8
  0b01101111  // 9
};

void displayDigit(uint8_t n) {
    uint8_t val = patterns[n];

    // Update segments
    PORTD = (PORTD & 0b00000111) | ((val & 0b00011111) << 3); // a-e
    PORTB = (PORTB & 0b11111100) | ((val & 0b01100000) >> 5); // f,g
}

// Timer interrupt for counting
ISR(TIMER1_COMPA_vect) {
    if (!paused) {
        digit = (digit + 1) % 10; // Increment
        displayDigit(digit); // Update display
    }
    PINB |= (1 << PB5); // Toggle LED
}

// Button interrupt to pause/resume
ISR(INT0_vect) {
    paused = !paused; // Toggle pause
    PINB |= (1 << PB5); // Toggle LED
}

void setup() {

    DDRD |= (1 << PD3) | (1 << PD4) | (1 << PD5) | (1 << PD6) | (1 << PD7); // Set segments a-e
    DDRB |= (1 << PB0) | (1 << PB1) | (1 << PB5); // Set segments f,g and LED

    DDRD &= ~(1 << PD2); // Set PD2 as input (button)
    PORTD |= (1 << PD2); // Enable pull-up

    EICRA |= (1 << ISC01); // Trigger INT0 on falling edge
    EIMSK |= (1 << INT0); // Enable INT0

    TCCR1A = 0;      
    TCCR1B = 0;
    TCCR1B |= (1 << WGM12); // CTC mode
    TCCR1B |= (1 << CS12); // Prescaler 256

    OCR1A = 31249; // 0.5s timer
    TIMSK1 |= (1 << OCIE1A); // Enable interrupt

    sei(); // Enable global interrupt

    displayDigit(0);  // Display 0
}

void loop() {
    // Empty
}
